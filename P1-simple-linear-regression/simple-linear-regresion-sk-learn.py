# -*- coding: utf-8 -*-
"""Copy of 02 Regresión Lineal SKLEARN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g_oBvBHqYQmeR2XUJucTdq82kQdueOZ0

# Modelo regresor con SKLEARN
"""

import numpy as np
import pandas as pd

# 1. Generar datos simulados
np.random.seed(42)  # Para reproducibilidad
n = 20  # Número de estudiantes
horas_estudio = np.random.uniform(0, 10, n)  # Entre 0 y 10 horas / semana

# Relación lineal: Nota = 40 + 5*horas + ruido
# Esta relación se propone de acuerdo a la experiencia académica del docente, dado que son datos simulados, se asume que si se estudia
#poco tiempo, el desempeño será bajo, y viceversa.
# Alguien que estudia 10 horas (Máximo) obtendrá como mínimo un 40 + 5.5*10 = 95
# Alguien que estudia 0 horas (Máximo) obtendrá como mínimo un 40 + 5.5*0 = 0
# El ruido añade variabilidad (Nervios, retraso, estrés, problemas personales, incomodidad, distracciones, miedo, suerte, ayuda, respuesta murmuradas, etc).
ruido = np.random.uniform(-5, 5, n)

nota = 40 + 5.5 * horas_estudio + ruido

# Crear el conjunto de datos (DATAFRAME) X -> Y
data = pd.DataFrame({'Horas': horas_estudio, 'Nota': nota})

print(data)

from sklearn.linear_model import LinearRegression

# 2. Definir las variables del modelo
X = data[['Horas']]  # Predictor [Formato de matriz]
y = data['Nota'] # Respuesta [Formato de vector]
modelo = LinearRegression()


print(f'Modelo: {modelo}')

# 3. Obtener modelo
modelo.fit(X, y)

beta_0 = modelo.intercept_
beta_1 = modelo.coef_[0]

print(f'Intercepto: {beta_0}')
print(f'Pendiente: {beta_1}')

print(f'Modelo lineal predecido: y = {beta_0:.4f} + {beta_1:.4f} * x')

# 4. Evaluación del modelo
from sklearn.metrics import r2_score, mean_squared_error

# Cálculo de R²
r2 = modelo.score(X, y)

# Cálculo del Mean Squared Error (MSE)
# Predicciones
y_pred = beta_0 + beta_1 * X
mse = mean_squared_error(y, y_pred)

# Cálculo del Root Mean Squared Error (RMS)
rms = np.sqrt(mse)

# Imprimir resultados
print("=== RESULTADOS DEL MODELO ===")
print(f"R²: {r2:.4f}")
print(f"Root Mean Squared Error (RMS): {rms:.4f}")

import matplotlib.pyplot as plt
#import seaborn as sns

# 5. Nuevas predicciones sobre todo el dominio del modelo (De 0 a 10 horas / semana)
X_linea = pd.DataFrame(np.linspace(0, 10, 100), columns=["Horas"])  # X_linea ahora es un DataFrame
y_pred_linea = modelo.predict(X_linea)

# 6. Gráfico de dispersión y recta ajustada
plt.figure(figsize=(8, 6))
plt.scatter(x='Horas', y='Nota', data=data, color='blue', label='Datos reales')
plt.plot(X_linea, y_pred_linea, color='red', linewidth=2, label='Recta ajustada')
plt.title('Horas de Estudio vs Nota')
plt.xlabel('Horas de Estudio')
plt.ylabel('Nota')
plt.legend()
plt.grid(True)
plt.show()

# Generar diferentes horas dentro del dominio
nuevas_horas = pd.DataFrame({'Horas': [0, 2, 5, 8, 10]})  # Ahora con nombre de columna

nuevas_predicciones = modelo.predict(nuevas_horas)

Predicciones = pd.DataFrame({'Horas': nuevas_horas['Horas'], 'Predicción': nuevas_predicciones})

# Imprimir DataFrame
print(Predicciones)

# 9. Estadística del residuo

y_pred = modelo.predict(X)
epsilon = y - y_pred

media_epsilon = np.mean(epsilon)
estandar_epsilon = np.std(epsilon)
RMSE_epsilon = np.sqrt(mean_squared_error(y, y_pred))
print("\n=== ESTADÍSTICAS DE RESIDUOS ===")
print(f"Media de residuos: {media_epsilon:.4f}")
print(f"Desviación estándar de residuos: {estandar_epsilon:.4f}")
print(f"RMSE: {RMSE_epsilon:.4f}")

# 5. Verificar homocedasticidad con gráfico de residuos
plt.figure(figsize=(8, 6))
plt.scatter(y_pred, epsilon, color='blue', label = '$\\epsilon_{i}$')
plt.axhline(0, color='black', linestyle='--', label='$\\epsilon=0$')
plt.title('Chequeo de homocedasticidad')
plt.xlabel('Predicción $\\hat{y}$')
plt.ylabel('Residuo $\\epsilon$')
plt.grid(True)
plt.legend()
plt.show()

# 6. Histograma de residuos (para ver distribución centrada en cero)
plt.figure(figsize=(7, 5))
plt.hist(epsilon, bins=20, color='skyblue', edgecolor='white')
plt.title("Distribución de Residuos")
plt.axvline(np.mean(epsilon), color='red', linestyle='--', label='Media de residuos')
plt.xlabel('$\\epsilon$')
plt.ylabel('Frecuencia')
plt.show()

